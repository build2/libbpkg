// file      : bpkg/manifest -*- C++ -*-
// copyright : Copyright (c) 2014-2015 Code Synthesis Ltd
// license   : MIT; see accompanying LICENSE file

#ifndef BPKG_MANIFEST
#define BPKG_MANIFEST

#include <string>
#include <vector>
#include <algorithm> // move()

#include <butl/optional>

namespace bpkg
{
  class manifest_parser;
  class manifest_serializer;
  class manifest_name_value;

  using strings = std::vector<std::string>;

  // priority
  //
  class priority
  {
  public:
    enum value_type {low, medium, high, security};

    value_type value; // Shouldn't be necessary to access directly.
    std::string comment;

    priority (value_type v = low, std::string c = "")
        : value (v), comment (std::move (c)) {}

    operator value_type () const {return value;}
  };

  // description
  // description-file
  //
  struct description: std::string
  {
    bool file;
    std::string comment;

    // Description constructor.
    //
    explicit
    description (std::string d = "")
        : std::string (std::move (d)), file (false) {}

    // Description file constructor.
    //
    description (std::string f, std::string c)
        : std::string (std::move (f)), file (true), comment (std::move (c)) {}
  };

  // license
  //
  struct licenses: strings
  {
    std::string comment;

    explicit
    licenses (std::string c = ""): comment (std::move (c)) {}
  };

  // change
  // change-file
  //
  struct change: std::string
  {
    bool file;
    std::string comment;

    // Change constructor.
    //
    explicit
    change (std::string c = ""): std::string (std::move (c)), file (false) {}

    // Change file constructor.
    //
    change (std::string f, std::string c)
        : std::string (std::move (f)), file (true), comment (std::move (c)) {}
  };

  // url
  // package-url
  //
  struct url: std::string
  {
    std::string comment;

    explicit
    url (std::string u = "", std::string c = "")
        : std::string (std::move (u)), comment (std::move (c)) {}
  };

  // email
  // package-email
  //
  struct email: std::string
  {
    std::string comment;

    explicit
    email (std::string e = "", std::string c = "")
        : std::string (std::move (e)), comment (std::move (c)) {}
  };

  // depends
  //
  enum class comparison {eq, lt, gt, le, ge};

  struct version_comparison
  {
    std::string value;
    comparison operation;
  };

  struct dependency
  {
    std::string name;
    butl::optional<version_comparison> version;
  };

  struct dependency_alternatives: std::vector<dependency>
  {
    bool conditional;
    std::string comment;

    explicit
    dependency_alternatives (bool d = false, std::string c = "")
        : conditional (d), comment (std::move (c)) {}
  };

  // requires
  //
  struct requirement_alternatives: strings
  {
    bool conditional;
    std::string comment;

    explicit
    requirement_alternatives (bool d = false, std::string c = "")
        : conditional (d), comment (std::move (c)) {}
  };

  class package_manifest
  {
  public:
    using priority_type = bpkg::priority;
    using url_type = bpkg::url;
    using email_type = bpkg::email;
    using description_type = bpkg::description;

    std::string name;
    std::string version;
    butl::optional<priority_type> priority;
    std::string summary;
    std::vector<licenses> license_alternatives;
    strings tags;
    butl::optional<description_type> description;
    std::vector<change> changes;
    url_type url;
    butl::optional<url_type> package_url;
    email_type email;
    butl::optional<email_type> package_email;
    std::vector<dependency_alternatives> dependencies;
    std::vector<requirement_alternatives> requirements;

  public:
    package_manifest (manifest_parser&);
    package_manifest (manifest_parser&, manifest_name_value start);

    void
    serialize (manifest_serializer&) const;
  };

  class repository_manifest
  {
  public:
    std::string location;

  public:
    repository_manifest (manifest_parser&);
    repository_manifest (manifest_parser&, manifest_name_value start);

    void
    serialize (manifest_serializer&) const;
  };

  class manifests
  {
  public:
    std::vector<repository_manifest> repositories;
    std::vector<package_manifest> packages;

  public:
    manifests (manifest_parser&);

    void
    serialize (manifest_serializer&) const;
  };
}

#endif // BPKG_MANIFEST
